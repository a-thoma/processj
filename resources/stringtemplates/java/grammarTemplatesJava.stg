delimiters "<",">"

Info() ::= <<
This file contains all of the templates for the ProcessJ JVM
compiler based on the intermediate representation generated by
the CodeGeneratorJava visitor.
>>

//========================================================================================
// Takes a ProcessJ file and turns it into a Java file that can be run
// again and again while maintaining the logical structure of the code
// translated by the ProcessJ JVM compiler. The parameters below represent
// what gets pushed into the template, and, for now, these parameters
// generate the entire code for a compilable Java file.
// 1) packageName: A region that organizes a set of related types,
//                 procedures, variables, etc.
// 2) filename: The name of a ProcessJ file.
// 3) name: The target class for the JVM.
// 4) body: A list of declarations generated from a ProcessJ source code.
// 5) imports: A list of import declarations.
Compilation(packageName, fileName, name, body, version, imports) ::= <<
import java.util.*;
import processj.runtime.*;
<if(imports)><imports; separator="\n"><endif>

/**
 * File generated by the ProcessJ JVM Compiler.
 * Package name '<packageName>'.
 * Code generation for '<fileName>'.
 * Target class '<name>'.
 * Java code version '<version>'.
 *
 * @author ProcessJ Group
 * @since 1.2
 *
 */
public class <name> {
    <if(body)><body; separator="\n\n"><endif>
}
>>

//========================================================================================
// A main method definition that represents the entry point of every
// ProcessJ program and one that is called by the JVM when the program
// is run.
// 1) class: the name of the class from which a 'main' process
//           can be created and then called by the JVM.
// 2) name: an instance of an entry point of any ProcessJ program.
// 3) types: the type of values associated with formal parameters.
// 4) vars: the names of the formal parameters.
Main(class, name, types, vars) ::= <<
public static void main(<types,vars:{t,v | <t> <v>}; separator=", ">) {
	Scheduler scheduler = new Scheduler();
    PJProcess.scheduler = scheduler;
    (new <class>.<name>(<vars; separator=", ">)).schedule();
    PJProcess.scheduler.start();
}
>>

//========================================================================================
// Defines a class from which a process is created. This template
// represents the set of properties and methods that are common to
// all objects that extend the PJProcess class. The class declarations
// can include the following components, in order:
// 1) name: the name of the class preceded by '_proc'.
// 2) types: data types for formal parameters.
// 3) vars: unique names for fields preceded by '_pd'.
// 4) ltypes: data types for local parameters.
// 5) lvars: unique names for fields preceded by '_ld'.
// 6) methods: collection of statements that perform an operation.
// 7) main: the entry point of the program.
// 8) switchBlock: switch statement to jump through blocks to resume points.
// 9) syncBody: the body (content) of synchronized method that runs/starts a process.
ProcClass(name, types, vars, ltypes, lvars, methods, main, switchBlock, syncBody) ::= <<
public static class <name> extends PJProcess {
    <! -------- Instance variables for formal parameters -------- !>
    <if(vars)><types,vars:{t,v | protected <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Instance variables for local parameters -------- !>
    <if(lvars)><ltypes,lvars:{t,v | protected <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Instance methods -------- !>
    <if(methods)><methods; separator="\n"><\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
    }

    <! Synchronized run method !>
    @Override
    public synchronized void run() {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
}
<! Entry point of the program,
   e.g. public static void main(String[] args) { ... }
!>
<if(main)><"\n"><main><endif>
>>

//========================================================================================
// An simple (or normal) invocation consists of associating the caller
// with the parameters that are used to invoked it. This will apply only
// to procedures that act and behave like any Java method (such methods
// are referred to by names and can be invoked at any point during the
// execution of the program) and ones that do not extend the class
// PJProcess.
// 1) name: the name of the invoked procedure.
// 2) vars: the names of the formal parameters.
Invocation(name, vars) ::= <<
<name>(<if(vars)><vars; separator=", "><endif>);
>>

//========================================================================================
//
InvocationProcType(name, vars, parBlock) ::= <<
(new <name>(<if(vars)><vars; separator=", "><endif>) {
    @Override
    public void finalize() {
        <parBlock>.decrement();
    }
}).schedule();
>>

//========================================================================================
// A method definition that specifies the types and names of parameters
// (which are separated by commas and enclosed in parenthesis and are
// required by methods during invocations), the access level such as
// 'public', 'private', or 'protected', the return value, a body between
// braces {}, and the name that uniquely identifies the method.
// 1) modifier: access level such as public, private, or protected.
// 2) type: the data type of the value returned by the method.
// 3) name: the name that uniquely applies and identifies the method.
// 4) types: the type of values associated to formal parameters.
// 5) vars: the names of the formal parameters preceded by '_ld'.
// 6) ltypes: data types for local parameters.
// 7) lvars: unique names for fields preceded by '_ld'.
// 8) body: the method body enclosed between braces.
Method(modifier, type, name, types, vars, ltypes, lvars, body) ::= <<
<if(modifier)><modifier> <endif>static <type> <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
    <! -------- Variables for local parameters -------- !>
    <if(lvars)><ltypes,lvars:{t,v | <t> <v>}; separator=";\n">;<\n><endif>
    <! The body may be an invocation or a sequence of statements !>
    <if(body)><body; separator="\n"><endif>
}
>>

//========================================================================================
// A declaration for a member variable that is defined outside of
// any methods but inside the class to which it belongs.
// 1) modifier: a keyword that defines the access of a field.
// 2) type: a data type that determines the value a variable can contain.
// 3) name: a qualified name for the member variable.
// 4) val: the value to be assigned to the member variable.
Field(modifier, type, name, val) ::= "<if(modifier)><modifier> <endif><Var(type, name, val)>;"

//========================================================================================
// Initializes a declaration for a variable given a type and a value.
// The declaration becomes a simple assignment statement if no type and
// no operator is specified. If a type is given, it becomes a new declaration
// in which a value may be assigned to the variable.
// 1) type: a data type that determines the value a variable can contain.
// 2) name: a qualified name for the variable.
// 3) val: the value to be assigned to the variable.
// 4) op: a build-in operator used to manipulate data and variables.
Var(type, name, val, op) ::= "<Type(type)><name><Init(val, op)>"
Type(type) ::= "<if(type)><type> <endif>"
Init(val, op) ::= "<if(val)> <if(op)><op><else>=<endif> <val><else>;<endif>"

//========================================================================================
// Defines a 'switch' block containing labels. These labels are used to
// route the flow of control to the resume points of different processes.
// 1) jumps: a list of cases generated by 'SwitchCase'.
SwitchBlock(jumps) ::= <<
<if(jumps)>
switch (this.runLabel) {
    case 0: break;
    <jumps; separator="\n">
    default: break;
}
<endif>
>>

//========================================================================================
// Defines a statement in a 'switch' block with one case. The
// case evaluates to a label representing the resume point of
// a PJProcess. 
// 1) jump: the label to restart from.
SwitchCase(jump) ::= "case <jump>: resume(<jump>); break;"

//========================================================================================
// Initializes a declaration for a 'par' statement (an object of type PJPar)
// defined in a process (an object of type PJProcess). This 'par' statement
// becomes a variable of the process in which it is declared. A reference
// to the process in which the 'par' appears and the number of processes
// found in the 'par' block are used to create a PJPar instance.
// 1) name: the name that uniquely applies and identifies the 'par' block.
// 2) count: the number of processes to run concurrently.
// 3) process: the reference to the process in which the 'par' block is defined.
// 4) body: the statements inside the 'par' block.
// 5) jump: the label to restart from.
ParBlock(name, count, process, body, jump) ::= <<
final PJPar <name> = new PJPar(<count>, <process>);

<if(body)><body; separator="\n\n"><endif>

<! Not to be scheduled again until 'data' is ready !>
setNotReady();
this.runLabel = <jump>;
yield();
label(<jump>);<\n>
>>

//========================================================================================
// Defines an expression for an anonymous process which consist of a
// switch block that contains jump labels, a synchronized body that
// runs all, and a 'par' block defined in a procedure.
// 1) switchBlock: switch statement to jump through blocks to resume points.
// 2) syncBody: the body (content) of synchronized method that runs/starts a process.
// 3) parBlock:
AnonymousProcess(switchBlock, syncBody, parBlock) ::= <<
new PJProcess() {
    <! Synchronized run method !>
    @Override
    public synchronized void run() {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
    
    <! Finalize method !>
    @Override
    public void finalize() {
        <if(parBlock)><parBlock>.decrement();<endif>
    }
}.schedule();
>>

//========================================================================================
//
ChannelDecl(type) ::= "<if(type)>new <type>();<endif>"