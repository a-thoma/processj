delimiters "<",">"

Info() ::= <<
This file contains all of the templates for the ProcessJ JVM
compiler based on the intermediate representation generated by
the CodeGeneratorJava visitor.
>>

//========================================================================================
// Takes a ProcessJ file and turns it into a Java file that can be run
// again and again while maintaining the logical structure of the code
// translated by the ProcessJ JVM compiler. The parameters below represent
// what gets pushed into the template, and, for now, these parameters
// generate the entire code for a compilable Java file.
// 1) packageName: A region that organizes a set of related types,
//                 procedures, variables, etc.
// 2) filename: The name of a ProcessJ file.
// 3) name: The target class for the JVM.
// 4) body: A list of declarations generated from a ProcessJ source code.
// 5) imports: A list of import declarations.
Compilation(packageName, fileName, name, body, version, imports) ::= <<
import java.util.*;
import processj.runtime.*;
<if(imports)><imports; separator=";\n">;<\n><endif>

/**
 * File generated by the ProcessJ JVM Compiler.
 * Package name '<packageName>'.
 * Code generation for '<fileName>'.
 * Target class '<name>'.
 * Java code version '<version>'.
 *
 * @author ProcessJ Group - University of Nevada, Las Vegas
 * @since 1.2
 *
 */
public class <name> {
    // Temporary dirty fix for unreachable code due to infinite loop
    public static boolean isTrue() { return true; }
    
    <if(body)><body; separator="\n\n"><endif>
}
>>

//========================================================================================
// A main method definition that represents the entry point of every
// ProcessJ program and one that is called by the JVM when the program
// is run.
// 1) class: the name of the class from which a 'main' process
//           can be created and then called by the JVM.
// 2) name: an instance of an entry point of any ProcessJ program.
// 3) types: the type of values associated with formal parameters.
// 4) vars: the names of the formal parameters.
Main(class, name, types, vars) ::= <<
public static void main(<types,vars:{t,v | <t> <v>}; separator=", ">) {
	Scheduler scheduler = new Scheduler();
    PJProcess.scheduler = scheduler;
    (new <class>.<name>(<vars; separator=", ">)).schedule();
    PJProcess.scheduler.start();
}
>>

//========================================================================================
// Defines a class from which a process is created. This template
// represents the set of properties and methods that are common to
// all objects that extend the PJProcess class. The class declarations
// can include the following components, in order:
// 1) name: the name of the class preceded by '_proc'.
// 2) types: data types for formal parameters.
// 3) vars: unique names for fields preceded by '_pd'.
// 4) ltypes: data types for local parameters.
// 5) lvars: unique names for fields preceded by '_ld'.
// 6) methods: collection of statements that perform an operation.
// 7) main: the entry point of the program.
// 8) switchBlock: switch statement to jump through blocks to resume points.
// 9) syncBody: the body (content) of synchronized method that runs/starts a process.
ProcClass(name, types, vars, ltypes, lvars, methods, main, switchBlock, syncBody) ::= <<
public static class <name> extends PJProcess {
    <! -------- Instance variables for formal parameters -------- !>
    <if(vars)><types,vars:{t,v | protected <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Instance variables for local parameters -------- !>
    <if(lvars)><ltypes,lvars:{t,v | protected <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Instance methods -------- !>
    <if(methods)><methods; separator="\n"><\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
    }

    <! Synchronized run method !>
    @Override
    public synchronized void run() {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
<! Entry point of the program, e.g.,
   public static void main(String[] args) { ... }
!>
<if(main)>}<\n><\n><main><else>}<endif>
>>

//========================================================================================
// An simple (or normal) invocation consists of associating the caller
// with the parameters that are used to invoked it. This will apply only
// to procedures that act and behave like any Java method (such methods
// are referred to by names and can be invoked at any point during the
// execution of the program) and ones that do not extend the class
// PJProcess.
// 1) name: the name of the invoked procedure.
// 2) vars: the names of the formal parameters.
Invocation(name, vars) ::= <<
<name>(<if(vars)><vars; separator=", "><endif>);
>>

//========================================================================================
//
// 1) name:
// 2) vars:
// 3) parBlock:
// 4) barrier:
InvocationProcType(name, vars, parBlock, barrier) ::= <<
(new <name>(<if(vars)><vars; separator=", "><endif>) {
    @Override
    public void finalize() {
        <parBlock>.decrement();
        <if(barrier)><barrier:{b | <b>.resign()}; separator=";\n">;<endif>
    }
}).schedule();
>>

//========================================================================================
// A method definition that specifies the types and names of parameters
// (which are separated by commas and enclosed in parenthesis and are
// required by methods during invocations), the access level such as
// 'public', 'private', or 'protected', the return value, a body between
// braces {}, and the name that uniquely identifies the method.
// 1) modifier: access level such as public, private, or protected.
// 2) type: the data type of the value returned by the method.
// 3) name: the name that uniquely applies and identifies the method.
// 4) types: the type of values associated to formal parameters.
// 5) vars: the names of the formal parameters preceded by '_ld'.
// 6) ltypes: data types for local parameters.
// 7) lvars: unique names for fields preceded by '_ld'.
// 8) body: the method body enclosed between braces.
Method(modifier, type, name, types, vars, ltypes, lvars, body) ::= <<
<if(modifier)><modifier> <endif>static <type> <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
    <! -------- Variables for local parameters -------- !>
    <if(lvars)><ltypes,lvars:{t,v | <t> <v>}; separator=";\n">;<\n><endif>
    <! The body may be an invocation or a sequence of statements !>
    <if(body)><body; separator="\n"><endif>
}
>>

//========================================================================================
// A declaration for a member variable that is defined outside of
// any methods but inside the class to which it belongs.
// 1) modifier: a keyword that defines the access of a field.
// 2) type: a data type that determines the value a variable can contain.
// 3) name: a qualified name for the member variable.
// 4) val: the value to be assigned to the member variable.
Field(modifier, type, name, val) ::= "<if(modifier)><modifier> <endif><Var(type, name, val)>;"

//========================================================================================
// Initializes a declaration for a variable given a type and a value.
// The declaration becomes a simple assignment statement if no type and
// no operator is specified. If a type is given, it becomes a new declaration
// in which a value may be assigned to the variable.
// 1) type: a data type that determines the value a variable can contain.
// 2) name: a qualified name for the variable.
// 3) val: the value to be assigned to the variable.
// 4) op: a build-in operator used to manipulate data and variables.
Var(type, name, val, op) ::= "<Type(type)><name><Init(val, op)>"
Type(type) ::= "<if(type)><type> <endif>"
Init(val, op) ::= "<if(val)> <if(op)><op><else>=<endif> <val>;<else>;<endif>"

//========================================================================================
// Defines a 'switch' block containing labels. These labels are used to
// route the flow of control to the resume points of different processes.
// 1) jumps: a list of cases generated by 'SwitchCase'.
SwitchBlock(jumps) ::= <<
<if(jumps)>
switch (this.runLabel) {
    case 0: break;
    <jumps; separator="\n">
    default: break;
}
<endif>
>>

//========================================================================================
// Defines a statement in a 'switch' block with one case. The
// case evaluates to a label representing the resume point of
// a process. 
// 1) jump: the label to restart from.
SwitchCase(jump) ::= "case <jump>: resume(<jump>); break;"

//========================================================================================
// Initializes a declaration for a 'par' statement (an object of type PJPar)
// defined in a process (an object of type PJProcess). This 'par' statement
// becomes a variable of the process in which it is declared. A reference
// to the process in which the 'par' appears and the number of processes
// found in the 'par' block are used to create a PJPar instance.
// 1) name: the name that uniquely applies and identifies the 'par' block.
// 2) count: the number of processes to run concurrently.
// 3) process: the reference to the process in which the 'par' block is defined.
// 4) body: the statements inside the 'par' block.
// 5) jump: the label to restart from.
// 6) barrier:
ParBlock(name, count, process, body, jump, barrier) ::= <<
final PJPar <name> = new PJPar(<count>, <process>);
<if(barrier)><barrier:{b | <b>.enroll(<count>)}; separator=";\n">;<endif>

<if(body)><body; separator="\n\n"><endif>

<! Not to be scheduled again until 'data' is ready !>
if (<name>.shouldYield()) {
    this.runLabel = <jump>;
    yield();
    label(<jump>);
}<\n>
>>

//========================================================================================
// Defines an expression for an anonymous process which consist of a
// switch block that contains jump labels, a synchronized body that
// runs all, and a 'par' block defined in a procedure. Note that the
// process's schedule() method is excluded iff it is created inside
// a 'par-for'. If this is case, then we generated code similar to
// that of a ProcessClass (e.g., with member fields).
// 1) switchBlock: switch statement to jump through blocks to resume points.
// 2) syncBody: the body (content) of synchronized method that runs/starts a process.
// 3) parBlock:
// 4) barrier:
// 5) ltypes: data types for local parameters that are used in a 'par-for'.
// 6) lvars: unique names for fields preceded by '_ld' that are used in a 'par-for'.
AnonymousProcess(switchBlock, syncBody, parBlock, barrier, ltypes, lvars) ::= <<
new PJProcess() {
    <! -------- Instance variables for local parameters -------- !>
    <if(lvars)><ltypes,lvars:{t,v | protected <t> <v>}; separator=";\n">;<\n><endif>
    <! Synchronized run method !>
    @Override
    public synchronized void run() {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
    
    <! Finalize method !>
    @Override
    public void finalize() {
        <if(parBlock)><parBlock>.decrement();<endif>
        <if(barrier)><barrier:{b | <b>.resign()}; separator=";\n">;<endif>
    } <!-- The setter should be called inside the generated code for a 'par-for'.
           Such an invocation means that the 'anonymous' process will be scheduled
           later in a separate for loop. Otherwise, the process should be schedule
           right away. --!>
}<if(lvars)>.set(<lvars; separator=", ">)<else>.schedule()<endif>;
>>

//========================================================================================
//
// 1) type:
ChannelDecl(type) ::= "<if(type)>new <type>()<endif>"

//========================================================================================
//
// 1) count:
BarrierDecl(count) ::= "new PJBarrier(<if(count)><count><endif>)"

//========================================================================================
//
// 1) name:
TimerRedExpr(name) ::= "<name> = PJTimer.read();"

//========================================================================================
//
// 1) value:
// 2) type:
PrimitiveLiteral(value, type) ::= "<value><if(type)><type><endif>"

//========================================================================================
//
// 1) name:
// 2) delay:
// 3) resume0:
TimeoutStat(name, delay, resume0) ::= <<
<name> = new PJTimer(this, <delay>);
try {
    <name>.start();
    setNotReady();
    this.runLabel = <resume0>;
    yield();
} catch (InterruptedException e) {
    System.out.println("An Interrupted exception occurred for a timer!");
}
label(<resume0>);
>>

//========================================================================================
//
// 1) chaName: name of the write channel-end.
// 2) resume0:
// 3) resume1:
ChanWriteStat(chanName, writeExpr, resume0) ::= <<
<chanName>.write(this, <writeExpr>);
this.runLabel = <resume0>;
yield();
label(<resume0>);<\n>
>>

//========================================================================================
//
// 1) chaName: name of the write channel-end.
// 2) resume0:
// 3) resume1:
ChannelReadExpr(chanName, lhs, op, resume0, resume1) ::= <<
if (!<chanName>.isReadyToRead(this)) {
    this.runLabel = <resume0>;
    yield();
}

label(<resume0>);
<if(lhs)><lhs> <op> <chanName>.read(this);
<else><chanName>.read(this);
<endif>
this.runLabel = <resume1>;
yield();

label(<resume1>);<!-- remove 'line-feed' --!>
>>

//========================================================================================
//
// 1) chanName:
// 2) resume0:
// 3) resume1:
// 4) resume2:
ChannelOne2Many(chanName, lhs, op, resume0, resume1, resume2) ::= <<
if (!<chanName>.claimRead(this)) {
    this.runLabel = <resume0>;
    yield();
}
label(<resume0>);

if (!<chanName>.isReadyToRead(this)) {
    this.runLabel = <resume1>;
    yield();
}

label(<resume1>);
<if(lhs)><lhs> <op> <chanName>.read(this);
<else><chanName>.read(this);
<endif>
this.runLabel = <resume2>;

<chanName>.unclaimRead();

yield();
label(<resume2>);
>>

//========================================================================================
//
// 1) chanName:
// 2) writeExpr:
// 3) resume0:
// 4) resume1:
ChannelMany2One(chanName, writeExpr, resume0, resume1) ::= <<
if (!<chanName>.claimWrite(this)) {
    this.runLabel = <resume0>;
    yield();
}
label(<resume0>);

<chanName>.write(this, <writeExpr>);
this.runLabel = <resume1>;

yield();
label(<resume1>);

<chanName>.unclaimWrite();<\n>
>>

//========================================================================================
//
// 1) expr:
// 2) thenPart:
// 3) elsePart:
IfStat(expr, thenPart, elsePart) ::= <<
if (<expr>) {
    <thenPart; separator="\n">
}<if(elsePart)> else {
    <elsePart; separator="\n">
}<endif>
>>

//========================================================================================
//
// 1) name:
BreakStat(name) ::= <<
<if(name)><name><else>break;<endif>
>>

//========================================================================================
//
// 1) label:
SwitchLabel(label, tag) ::= <<
<if(label)>case <label><else>default<endif>
>>

//========================================================================================
//
// 1) labels:
// 2) stats:
SwitchGroup(labels, stats) ::= <<
<labels:{l | <l>:}; separator="\n">
    <stats; separator="\n">
>>

//========================================================================================
//
// 1) expr:
// 2) block:
SwitchStat(expr, block, tag) ::= <<
switch(<expr><if(tag)>.tag<endif>) {
<block; separator="\n">
}
>>

//========================================================================================
//
// 1) operand:
// 2) op:
UnaryPostExpr(operand, op) ::= "<if(operand)><operand><op>;<endif>"

//========================================================================================
//
// 1) operand:
// 2) op:
UnaryPreExpr(operand, op) ::= "<if(operand)><op><operand>;<endif>"

//========================================================================================
//
// 1) type:
// 2) expr:
CastExpr(type, expr) ::= "<if(type)>((<type>) (<expr>))<endif>"

//========================================================================================
//
// 1) lhs:
// 2) rhs:
// 3) op:
BinaryExpr(lhs, rhs, op) ::= <<
<lhs> <op> <rhs>
>>

//========================================================================================
//
// 1) package:
// 2) file
Import(package, file) ::= "import <package><if(file)>.<file><endif>"

//========================================================================================
//
// 1) modifier: access level such as public, private, or protected.
// 2) name: the name that uniquely applies and identifies the record.
// 3) types:
// 4) vars:
RecordClass(modifiers, name, types, vars) ::= <<
<if(modifiers)><modifiers; separator=" "> <else>protected <endif>static class <name> implements PJRecord {
    <! -------- Member variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
    }
}
>>

//========================================================================================
//
// 1) type:
// 2) vals:
RecordLiteral(type, vals) ::= <<
new <type>(<vals; separator=", ">)
>>

//========================================================================================
//
// 1) name:
// 2) member:
RecordAccess(name, member) ::= "<if(name)><name>.<member><endif>"

//========================================================================================
//
// 1) modifier: access level such as public, private, or protected.
// 2) name: the name that uniquely applies and identifies the protocol.
// 3) body:
ProtocolClass(modifiers, name, body) ::= <<
<if(modifiers)><modifiers; separator=" "> <else>protected <endif>static class <name> {
    <body; separator="\n\n">
}
>>

//========================================================================================
//
// 1) modifier:
// 2) name:
// 3) types:
// 4) vars:
ProtocolCase(modifier, name, types, vars) ::= <<
<if(modifier)><modifier> <else>protected <endif>static class <name> extends PJProtocolCase {
    <! -------- Member variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
        this.tag = "<name>";
    }
}
>>

//========================================================================================
//
// 1) name:
// 2) tag:
// 3) vals:
ProtocolLiteral(type, tag, vals) ::= <<
new <type>.<tag>(<if(vals)><vals; separator=", "><endif>)
>>

//========================================================================================
//
// 1) protocName:
// 2) tag:
// 3) var:
// 4) member:
ProtocolAccess(protocName, tag, var, member) ::= <<
<if(protocName)>(((<protocName>.<tag>) <var>).<member>)<endif>
>>

//========================================================================================
//
// 1) barrier:
// 2) resume0:
SyncStat(barrier, resume0) ::= <<
<barrier>.sync(this);
this.runLabel = <resume0>;
yield();
label(<resume0>);
>>

//========================================================================================
//
// 1) expr:
// 2) body:
WhileStat(expr, body) ::= <<
while (<expr>) {
    <if(body)><body; separator="\n"><endif>
}
>>

//========================================================================================
//
// 1) expr:
// 2) stats:
DoStat(expr, body) ::= <<
do {
    <if(body)><body; separator="\n"><endif>
} while (<expr>);
>>

//========================================================================================
//
// 1) init:
// 2) expr:
// 3) incr:
// 4) stats:
ForStat(init, expr, incr, stats) ::= <<
for (<if(init)><init; separator=", "><else>/* empty */<endif>;
     <if(expr)><expr><else>/* emtpy */<endif>;
     <if(incr)><incr; separator=", "><else>/* empty */<endif>) {
     
     <stats; separator="\n">
}
>>