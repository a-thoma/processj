delimiters "<",">"

Info() ::= <<
This file contains all of the templates for the ProcessJ JVM compiler based
on the intermediate representation generated by the CodeGeneratorJava visitor.
>>

//========================================================================================
// Takes a ProcessJ file and turns it into a Java file that can be run
// again and again while maintaining the logical structure of the code
// translated by the ProcessJ JVM compiler. The parameters below represent
// what gets pushed into the template, and, for now, these parameters
// generate the entire code for a compilable Java file.
// 1) packageName: A region that organizes a set of related types,
//                 procedures, variables, etc.
// 2) filename: The name of a ProcessJ file.
// 3) name: The target class for the JVM.
// 4) body: A list of declarations generated from a ProcessJ source code.
Compilation(packageName, fileName, name, body, version) ::= <<
import java.util.*;
import processj.runtime.*;

/**
 * File Generated by the ProcessJ JVM Compiler.
 * Package name `<packageName>'.
 * Code generation for `<fileName>'.
 * Target class `<name>'.
 * Java code version `<version>'.
 *
 * @author ProcessJ Group
 * @since 1.2
 */
public class <name> {
    <if(body)><body; separator="\n\n"><endif>
}
>>

//========================================================================================
// A main method definition that represents the entry point of every
// ProcessJ program and one that is called by the JVM when the program
// is run.
// 1) class: the name of the class from which a `main' process
//           can be created and then called by the JVM.
// 2) name: an instance of an entry point of any ProcessJ program.
// 3) types: the type of values associated with formal parameters.
// 4) vars: the names of the formal parameters.
Main(class, name, types, vars) ::= <<
public static void main(<types,vars:{t,v | <t> <v>}; separator=", ">) {
	Scheduler scheduler = new Scheduler();
    PJProcess.scheduler = scheduler;
    (new <class>.<name>(<vars; separator=", ">)).schedule();
    PJProcess.scheduler.start();
}
>>

//========================================================================================
// Defines a class from which a process is created. This template
// represents the set of properties and methods that are common to
// all objects that extend a PJProcess class. The class declarations
// can include the following components, in order:
// 1) name: the name of the class preceded by `_proc'.
// 2) types: data types that determine the values fields can contain.
// 3) vars: unique names for fields preceded by `_pd' or `_ld'.
// 4) methods: collection of statements that perform an operation.
// 5) main: the entry point of the program.
// 6) syncBody: the body(content) of synchronized method that runs/starts a process.
ProcClass(name, types, vars, methods, main, syncBody) ::= <<
public static class <name> extends PJProcess {
    <! -------- Instance variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Instance methods -------- !>
    <if(methods)><methods; separator="\n"><\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
    }

    <! Synchronized run method !>
    @Override
    public synchronized void run() {
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
}
<! Entry point of the program,
   e.g. public static void main(String[] args) { ... }
!>
<if(main)><"\n"><main><endif>
>>


//========================================================================================
// An simple (or normal) invocation consists of associating the caller
// with the parameters that are used to invoked it. This will apply only
// to procedures that act and behave like any Java method (such methods
// are referred to by names and can be invoked at any point during the
// execution of the program) and ones that do not extend the class
// PJProcess.
// 1) name: the name of the invoked procedure.
// 2) vars: the names of the formal parameters.
Invocation(name, vars) ::= <<
<name>(<if(vars)><vars; separator=", "><endif>);
>>

//========================================================================================
// A method definition that specifies the types and names of parameters
// (which are separated by commas and enclosed in parenthesis and are
// required by methods during invocations), the access level such as
// `public', `private', or `protected', the return value, a body between
// braces {}, and the name that uniquely identifies the method.
// 1) modifier: access level such as public, private, or protected.
// 2) type: the data type of the value returned by the method.
// 3) name: the name that uniquely applies and identifies the method.
// 4) types: the type of values associated to formal parameters.
// 5) vars: the names of the formal parameters.
// 6) body: the method body enclosed between braces.
Method(modifier, type, name, types, vars, body) ::= <<
<modifier> static <type> <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
    <! The body may be an invocation or a sequence of statements !>
    <body>
}
>>

//========================================================================================
// A declaration for a member variable that is defined outside of
// any methods but inside the class to which it belongs.
// 1) modifier: a keyword that defines the access of a field.
// 2) type: a data type that determines the value a variable can contain.
// 3) name: a qualified name for the member variable.
// 4) val: the value to be assigned to the member variable.
Field(modifier, type, name, val) ::= "<if(modifier)><modifier> <endif><Var(type, name, val)>;"

//========================================================================================
// Initializes a declaration for a variable given a type and a value.
// The declaration becomes a simple assignment statement if no type is
// specified. If a type is given, it becomes a new declaration in which a
// value may be assigned to the variable.
// 1) type: a data type that determines the value a variable can contain.
// 2) name: a qualified name for the variable.
// 3) val: the value to be assigned to the variable.
Var(type, name, val) ::= "<Type(type)><name><Init(val)>"
Type(type) ::= "<if(type)><type> <endif>"
Init(val) ::= "<if(val)> = <val>;<endif>"
